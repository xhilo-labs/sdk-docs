# useXhiloPiLogs Hook

A specialized hook that provides access to console logs for debugging Pi Network SDK operations.

## üìã Overview

`useXhiloPiLogs` is a debugging hook that provides access to console logs generated by the Pi Network SDK. It's useful for troubleshooting, monitoring SDK operations, and understanding what's happening behind the scenes.

## üöÄ Basic Usage

```tsx
import { useXhiloPiLogs } from '@xhilo/pi-sdk';

function DebugComponent() {
  const { logs, getLogs, clearLogs } = useXhiloPiLogs();

  return (
    <div>
      <h3>Pi SDK Debug Logs</h3>
      <button onClick={clearLogs}>Clear Logs</button>
      <div className="logs-container">
        {logs.map((log, index) => (
          <div key={index} className={`log-entry log-${log.type}`}>
            <span className="timestamp">{log.timestamp}</span>
            <span className="type">{log.type}</span>
            <span className="message">{log.message}</span>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## üîß Prerequisites

This hook requires your app to be wrapped with `XhiloPiProvider`:

```tsx
import { XhiloPiProvider } from '@xhilo/pi-sdk';

function App() {
  return (
    <XhiloPiProvider>
      <YourApp />
    </XhiloPiProvider>
  );
}
```

## üì§ Return Values

- **`logs`** - `ConsoleLog[]` - Array of console logs
- **`getLogs`** - `() => ConsoleLog[]` - Function to get current logs
- **`clearLogs`** - `() => void` - Function to clear all logs

### `ConsoleLog` Interface

```tsx
interface ConsoleLog {
  type: 'log' | 'warn' | 'error' | 'success';  // Log type
  message: string;                              // Log message
  timestamp: string;                            // ISO timestamp
}
```

## üéØ When to Use This Hook

### ‚úÖ Use `useXhiloPiLogs` when:
- You need to **debug Pi SDK operations**
- You want to **monitor SDK behavior** in real-time
- You're **troubleshooting** payment or authentication issues
- You need to **track SDK events** for analytics
- You're building **developer tools** or **debug panels**

### ‚ùå Don't use `useXhiloPiLogs` when:
- You need **user-facing functionality** (use other hooks)
- You're building **production features** (logs are for debugging)
- You need **payment functionality** (use `usePiPayments` or `usePiSimplePayments`)

## üìù Detailed Examples

### 1. Basic Debug Panel

```tsx
function DebugPanel() {
  const { logs, clearLogs } = useXhiloPiLogs();

  return (
    <div className="debug-panel">
      <div className="debug-header">
        <h3>Pi SDK Debug Logs</h3>
        <button onClick={clearLogs} className="clear-btn">
          Clear Logs
        </button>
      </div>
      
      <div className="logs-container">
        {logs.length === 0 ? (
          <p className="no-logs">No logs available</p>
        ) : (
          logs.map((log, index) => (
            <div key={index} className={`log-entry log-${log.type}`}>
              <span className="log-timestamp">
                {new Date(log.timestamp).toLocaleTimeString()}
              </span>
              <span className="log-type">{log.type.toUpperCase()}</span>
              <span className="log-message">{log.message}</span>
            </div>
          ))
        )}
      </div>
    </div>
  );
}
```

### 2. Real-time Log Monitor

```tsx
function LogMonitor() {
  const { logs, getLogs } = useXhiloPiLogs();
  const [autoScroll, setAutoScroll] = useState(true);
  const logsRef = useRef(null);

  useEffect(() => {
    if (autoScroll && logsRef.current) {
      logsRef.current.scrollTop = logsRef.current.scrollHeight;
    }
  }, [logs, autoScroll]);

  const exportLogs = () => {
    const logData = getLogs().map(log => ({
      timestamp: log.timestamp,
      type: log.type,
      message: log.message
    }));
    
    const blob = new Blob([JSON.stringify(logData, null, 2)], {
      type: 'application/json'
    });
    
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pi-sdk-logs-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="log-monitor">
      <div className="monitor-header">
        <h3>Real-time Log Monitor</h3>
        <div className="monitor-controls">
          <label>
            <input
              type="checkbox"
              checked={autoScroll}
              onChange={(e) => setAutoScroll(e.target.checked)}
            />
            Auto-scroll
          </label>
          <button onClick={exportLogs}>Export Logs</button>
        </div>
      </div>
      
      <div ref={logsRef} className="logs-container">
        {logs.map((log, index) => (
          <div key={index} className={`log-entry log-${log.type}`}>
            <span className="log-timestamp">
              {new Date(log.timestamp).toLocaleString()}
            </span>
            <span className="log-type">{log.type}</span>
            <span className="log-message">{log.message}</span>
          </div>
        ))}
      </div>
      
      <div className="log-stats">
        <span>Total logs: {logs.length}</span>
        <span>Errors: {logs.filter(log => log.type === 'error').length}</span>
        <span>Warnings: {logs.filter(log => log.type === 'warn').length}</span>
      </div>
    </div>
  );
}
```

### 3. Filtered Log Viewer

```tsx
function FilteredLogViewer() {
  const { logs, clearLogs } = useXhiloPiLogs();
  const [filter, setFilter] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');

  const filteredLogs = logs.filter(log => {
    const matchesFilter = filter === 'all' || log.type === filter;
    const matchesSearch = log.message.toLowerCase().includes(searchTerm.toLowerCase());
    return matchesFilter && matchesSearch;
  });

  const logTypes = ['all', 'log', 'warn', 'error', 'success'];

  return (
    <div className="filtered-log-viewer">
      <div className="viewer-header">
        <h3>Filtered Log Viewer</h3>
        <button onClick={clearLogs}>Clear All</button>
      </div>
      
      <div className="filters">
        <div className="filter-group">
          <label>Filter by type:</label>
          <select value={filter} onChange={(e) => setFilter(e.target.value)}>
            {logTypes.map(type => (
              <option key={type} value={type}>
                {type.charAt(0).toUpperCase() + type.slice(1)}
              </option>
            ))}
          </select>
        </div>
        
        <div className="filter-group">
          <label>Search:</label>
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            placeholder="Search logs..."
          />
        </div>
      </div>
      
      <div className="logs-container">
        {filteredLogs.length === 0 ? (
          <p className="no-logs">No logs match your filters</p>
        ) : (
          filteredLogs.map((log, index) => (
            <div key={index} className={`log-entry log-${log.type}`}>
              <span className="log-timestamp">
                {new Date(log.timestamp).toLocaleTimeString()}
              </span>
              <span className="log-type">{log.type.toUpperCase()}</span>
              <span className="log-message">{log.message}</span>
            </div>
          ))
        )}
      </div>
      
      <div className="log-summary">
        <p>Showing {filteredLogs.length} of {logs.length} logs</p>
      </div>
    </div>
  );
}
```

### 4. Error Tracking

```tsx
function ErrorTracker() {
  const { logs } = useXhiloPiLogs();
  const [errorCount, setErrorCount] = useState(0);
  const [lastError, setLastError] = useState(null);

  useEffect(() => {
    const errors = logs.filter(log => log.type === 'error');
    setErrorCount(errors.length);
    
    if (errors.length > 0) {
      setLastError(errors[errors.length - 1]);
    }
  }, [logs]);

  const getErrorRate = () => {
    if (logs.length === 0) return 0;
    return ((errorCount / logs.length) * 100).toFixed(1);
  };

  return (
    <div className="error-tracker">
      <h3>Error Tracking</h3>
      
      <div className="error-stats">
        <div className="stat-item">
          <span className="stat-label">Total Errors:</span>
          <span className="stat-value error-count">{errorCount}</span>
        </div>
        
        <div className="stat-item">
          <span className="stat-label">Error Rate:</span>
          <span className="stat-value error-rate">{getErrorRate()}%</span>
        </div>
        
        <div className="stat-item">
          <span className="stat-label">Total Logs:</span>
          <span className="stat-value total-logs">{logs.length}</span>
        </div>
      </div>
      
      {lastError && (
        <div className="last-error">
          <h4>Last Error:</h4>
          <div className="error-details">
            <p><strong>Time:</strong> {new Date(lastError.timestamp).toLocaleString()}</p>
            <p><strong>Message:</strong> {lastError.message}</p>
          </div>
        </div>
      )}
      
      {errorCount > 0 && (
        <div className="error-actions">
          <button onClick={() => console.log('Report errors to support')}>
            Report Errors
          </button>
        </div>
      )}
    </div>
  );
}
```

### 5. Performance Monitor

```tsx
function PerformanceMonitor() {
  const { logs } = useXhiloPiLogs();
  const [performanceMetrics, setPerformanceMetrics] = useState({
    totalOperations: 0,
    averageResponseTime: 0,
    successRate: 0
  });

  useEffect(() => {
    const successLogs = logs.filter(log => log.type === 'success');
    const errorLogs = logs.filter(log => log.type === 'error');
    const totalOperations = successLogs.length + errorLogs.length;
    
    // Calculate success rate
    const successRate = totalOperations > 0 ? (successLogs.length / totalOperations) * 100 : 0;
    
    // Calculate average response time (simplified)
    const responseTimes = logs
      .filter(log => log.message.includes('completed') || log.message.includes('success'))
      .map(log => {
        // Extract time from log message (simplified)
        const timeMatch = log.message.match(/(\d+)ms/);
        return timeMatch ? parseInt(timeMatch[1]) : 0;
      })
      .filter(time => time > 0);
    
    const averageResponseTime = responseTimes.length > 0 
      ? responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length 
      : 0;

    setPerformanceMetrics({
      totalOperations,
      averageResponseTime: Math.round(averageResponseTime),
      successRate: Math.round(successRate * 100) / 100
    });
  }, [logs]);

  return (
    <div className="performance-monitor">
      <h3>Performance Metrics</h3>
      
      <div className="metrics-grid">
        <div className="metric-card">
          <h4>Total Operations</h4>
          <div className="metric-value">{performanceMetrics.totalOperations}</div>
        </div>
        
        <div className="metric-card">
          <h4>Success Rate</h4>
          <div className="metric-value success-rate">
            {performanceMetrics.successRate}%
          </div>
        </div>
        
        <div className="metric-card">
          <h4>Avg Response Time</h4>
          <div className="metric-value response-time">
            {performanceMetrics.averageResponseTime}ms
          </div>
        </div>
      </div>
      
      <div className="performance-chart">
        <h4>Recent Activity</h4>
        <div className="activity-timeline">
          {logs.slice(-10).map((log, index) => (
            <div key={index} className={`activity-item ${log.type}`}>
              <span className="activity-time">
                {new Date(log.timestamp).toLocaleTimeString()}
              </span>
              <span className="activity-message">{log.message}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 6. Log Search and Analysis

```tsx
function LogAnalyzer() {
  const { logs } = useXhiloPiLogs();
  const [searchQuery, setSearchQuery] = useState('');
  const [analysis, setAnalysis] = useState(null);

  const analyzeLogs = () => {
    const query = searchQuery.toLowerCase();
    const matchingLogs = logs.filter(log => 
      log.message.toLowerCase().includes(query)
    );

    const analysis = {
      totalMatches: matchingLogs.length,
      typeDistribution: {},
      timeRange: {
        start: matchingLogs[0]?.timestamp,
        end: matchingLogs[matchingLogs.length - 1]?.timestamp
      },
      commonPatterns: []
    };

    // Analyze type distribution
    matchingLogs.forEach(log => {
      analysis.typeDistribution[log.type] = (analysis.typeDistribution[log.type] || 0) + 1;
    });

    // Find common patterns (simplified)
    const patterns = {};
    matchingLogs.forEach(log => {
      const words = log.message.split(' ').filter(word => word.length > 3);
      words.forEach(word => {
        patterns[word] = (patterns[word] || 0) + 1;
      });
    });

    analysis.commonPatterns = Object.entries(patterns)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([word, count]) => ({ word, count }));

    setAnalysis(analysis);
  };

  return (
    <div className="log-analyzer">
      <h3>Log Analyzer</h3>
      
      <div className="search-section">
        <input
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          placeholder="Search logs..."
          className="search-input"
        />
        <button onClick={analyzeLogs} className="analyze-btn">
          Analyze
        </button>
      </div>
      
      {analysis && (
        <div className="analysis-results">
          <h4>Analysis Results</h4>
          
          <div className="analysis-stats">
            <p><strong>Total Matches:</strong> {analysis.totalMatches}</p>
            <p><strong>Time Range:</strong> {
              analysis.timeRange.start && analysis.timeRange.end
                ? `${new Date(analysis.timeRange.start).toLocaleString()} - ${new Date(analysis.timeRange.end).toLocaleString()}`
                : 'N/A'
            }</p>
          </div>
          
          <div className="type-distribution">
            <h5>Type Distribution:</h5>
            {Object.entries(analysis.typeDistribution).map(([type, count]) => (
              <div key={type} className="type-item">
                <span className="type-name">{type}:</span>
                <span className="type-count">{count}</span>
              </div>
            ))}
          </div>
          
          <div className="common-patterns">
            <h5>Common Patterns:</h5>
            {analysis.commonPatterns.map(({ word, count }, index) => (
              <div key={index} className="pattern-item">
                <span className="pattern-word">{word}:</span>
                <span className="pattern-count">{count}</span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

## üé® Styling Examples

### CSS for Log Components

```css
.debug-panel {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 8px;
  padding: 20px;
  margin: 20px 0;
}

.debug-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
}

.logs-container {
  max-height: 400px;
  overflow-y: auto;
  background: #fff;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  padding: 10px;
}

.log-entry {
  display: flex;
  gap: 10px;
  padding: 5px 0;
  border-bottom: 1px solid #f1f3f4;
  font-family: monospace;
  font-size: 12px;
}

.log-entry:last-child {
  border-bottom: none;
}

.log-timestamp {
  color: #6c757d;
  min-width: 80px;
}

.log-type {
  font-weight: bold;
  min-width: 60px;
}

.log-type.log-LOG { color: #007bff; }
.log-type.log-WARN { color: #ffc107; }
.log-type.log-ERROR { color: #dc3545; }
.log-type.log-SUCCESS { color: #28a745; }

.log-message {
  flex: 1;
  word-break: break-word;
}

.monitor-controls {
  display: flex;
  gap: 15px;
  align-items: center;
}

.log-stats {
  display: flex;
  gap: 20px;
  margin-top: 10px;
  font-size: 14px;
  color: #6c757d;
}

.error-tracker {
  background: #fff5f5;
  border: 1px solid #fed7d7;
  border-radius: 8px;
  padding: 20px;
  margin: 20px 0;
}

.error-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin: 20px 0;
}

.stat-item {
  display: flex;
  justify-content: space-between;
  padding: 10px;
  background: #fff;
  border-radius: 4px;
  border: 1px solid #e2e8f0;
}

.metric-card {
  background: #fff;
  border: 1px solid #e2e8f0;
  border-radius: 8px;
  padding: 20px;
  text-align: center;
}

.metric-value {
  font-size: 24px;
  font-weight: bold;
  margin-top: 10px;
}

.success-rate { color: #28a745; }
.response-time { color: #007bff; }
.error-count { color: #dc3545; }
```

## ‚ö†Ô∏è Important Notes

1. **Provider Required** - Must be used within `XhiloPiProvider`
2. **Debugging Only** - Not for production user-facing features
3. **Performance** - Logs are limited to 100 entries to prevent memory issues
4. **Real-time** - Logs update automatically as new entries are added
5. **Memory Management** - Old logs are automatically removed when limit is reached

## üîó Related Hooks

- [`useXhiloPi`](./useXhiloPi.md) - Full Pi Network context
- [`useXhiloPiUser`](./useXhiloPiUser.md) - User information
- [`useXhiloPiReady`](./useXhiloPiReady.md) - SDK readiness
